{
  "basic-echo": {
    "name": "Basic Echo",
    "shortDescription": "Simple echo service for testing",
    "description": "A basic HTTP proxy that demonstrates simple request/response handling. Perfect for understanding the fundamentals of proxy configuration and routing.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Learning & Testing",
        "description": "Understand proxy basics with a simple echo endpoint"
      },
      {
        "title": "Development",
        "description": "Quick prototyping and validation of HTTP flows"
      },
      {
        "title": "Health Checks",
        "description": "Simple endpoint for monitoring and diagnostics"
      }
    ],
    "prerequisites": [
      "HTTP service"
    ],
    "directory": "basic-echo",
    "file": "basic-echo/pipelines/basic-echo.toml",
    "type": "pipeline",
    "hidden": true
  },
  "http-external": {
    "name": "External API Gateway",
    "shortDescription": "HTTP gateway for an API service",
    "description": "Full-featured HTTP gateway with path filtering, content-type negotiation, and flexible backend routing. Foundation for modern API integration.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "API Gateway",
        "description": "Central proxy for backend service routing"
      },
      {
        "title": "Path-Based Routing",
        "description": "Route requests by URL path to different backends"
      },
      {
        "title": "Request Filtering",
        "description": "Filter and transform requests before forwarding"
      }
    ],
    "prerequisites": [
      "HTTP Service"
    ],
    "directory": "http-external",
    "file": "http-external/pipelines/http-external.toml",
    "type": "pipeline",
    "featured": true
  },
  "http-internal": {
    "name": "Internal API Gateway",
    "shortDescription": "HTTP backend to prevent external access to admin paths",
    "description": "Full-featured HTTP gateway with path filtering, content-type negotiation, and flexible backend routing. Foundation for modern API integration.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Access control",
        "description": "Restrict access for admin services"
      },
      {
        "title": "VPN routing",
        "description": "Route internal, VPN requests to different services"
      },
      {
        "title": "Request Filtering",
        "description": "Filter and transform requests before forwarding"
      }
    ],
    "prerequisites": [
      "HTTP Service"
    ],
    "directory": "http-internal",
    "file": "http-internal/pipelines/http-internal.toml",
    "type": "pipeline",
    "featured": true
  },
  "http-http": {
    "name": "HTTP to HTTP",
    "shortDescription": "Basic HTTP API proxy",
    "description": "Basic HTTP API proxy demonstrating simple passthrough routing.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Simple Proxy",
        "description": "Proxy HTTP requests to a backend service"
      }
    ],
    "prerequisites": [
      "HTTP Service"
    ],
    "directory": "http-http",
    "file": "http-http/pipelines/http-http.toml",
    "type": "pipeline"
  },
  "http3-backend": {
    "name": "HTTP to HTTP/3 Backend",
    "shortDescription": "Proxy HTTP requests to HTTP/3 backends",
    "description": "Receive standard HTTP requests and forward them to backend servers using HTTP/3 over QUIC transport. Provides benefits like no head-of-line blocking, faster connections with 0-RTT resumption, and built-in TLS 1.3 encryption.",
    "tags": [
      "HTTP/3",
      "QUIC"
    ],
    "useCases": [
      {
        "title": "Modern API Integration",
        "description": "Connect to HTTP/3-enabled APIs with improved performance"
      },
      {
        "title": "High-Latency Networks",
        "description": "Better performance on lossy or high-latency networks"
      },
      {
        "title": "Backend Modernization",
        "description": "Leverage HTTP/3 backends without changing client infrastructure"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "HTTP/3-capable backend"
    ],
    "directory": "http3-backend",
    "file": "http3-backend/pipelines/http3-backend.toml",
    "type": "pipeline",
    "since": "0.11"
  },
  "http3-listener": {
    "name": "HTTP/3 to HTTP Backend",
    "shortDescription": "Accept HTTP/3 requests and proxy to HTTP backends",
    "description": "Receive HTTP/3 (QUIC) requests from modern clients and forward them to standard HTTP backend servers. Terminate QUIC/TLS 1.3 at the edge while keeping existing backend infrastructure.",
    "tags": [
      "HTTP/3",
      "QUIC"
    ],
    "useCases": [
      {
        "title": "Edge Termination",
        "description": "Terminate HTTP/3 at the edge, forward HTTP internally"
      },
      {
        "title": "Client Modernization",
        "description": "Support HTTP/3 clients without changing backends"
      },
      {
        "title": "Gradual Migration",
        "description": "Add HTTP/3 support incrementally to existing infrastructure"
      }
    ],
    "prerequisites": [
      "HTTP/3 Listener",
      "TLS Certificate",
      "HTTP Backend"
    ],
    "directory": "http3-listener",
    "file": "http3-listener/pipelines/http3-listener.toml",
    "type": "pipeline",
    "since": "0.11"
  },
  "dicom-cstore-to-filesystem": {
    "name": "DICOM C-STORE to Filesystem",
    "shortDescription": "Store DICOM images to local filesystem",
    "description": "Receive DICOM files via the C-STORE protocol and store them using the local filesystem backend.",
    "tags": [
      "Healthcare",
      "DICOM",
      "Storage",
      "Filesystem"
    ],
    "useCases": [
      {
        "title": "Image Archival",
        "description": "Store incoming DICOM images to disk"
      },
      {
        "title": "Local PACS",
        "description": "Simple file-based image storage"
      }
    ],
    "prerequisites": [
      "DICOM Service",
      "Filesystem Service"
    ],
    "directory": "cstore-filesystem",
    "file": "cstore-filesystem/pipelines/main.toml",
    "type": "pipeline"
  },
  "http-to-dicom": {
    "name": "DICOM Backend",
    "shortDescription": "HTTP to DICOM medical imaging proxy",
    "description": "Convert HTTP requests to DICOM operations (C-FIND, C-MOVE, C-STORE) targeting PACS systems. Enable REST access to DICOM infrastructure.",
    "tags": [
      "Healthcare",
      "DICOM",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "REST to DICOM",
        "description": "Access DICOM PACS systems via HTTP/REST API"
      },
      {
        "title": "Medical Imaging Integration",
        "description": "Query and retrieve DICOM studies from PACS"
      },
      {
        "title": "System Interoperability",
        "description": "Bridge modern APIs with legacy DICOM infrastructure"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "DICOM SCU Backend"
    ],
    "directory": "dicom-backend",
    "file": "dicom-backend/pipelines/dicom-backend.toml",
    "type": "pipeline"
  },
  "dicom-scp": {
    "name": "DICOM Receiver (SCP)",
    "shortDescription": "DICOM Service Class Provider endpoint",
    "description": "Receive DICOM images from medical modalities (CT, MRI, Ultrasound). Support C-ECHO, C-FIND, C-GET, and C-MOVE operations for PACS integration.",
    "tags": [
      "Healthcare",
      "DICOM"
    ],
    "useCases": [
      {
        "title": "Image Reception",
        "description": "Receive DICOM C-STORE from medical devices"
      },
      {
        "title": "Study Routing",
        "description": "Route received studies to archive or processing"
      },
      {
        "title": "Modality Gateway",
        "description": "Central point for medical device connectivity"
      }
    ],
    "prerequisites": [
      "DICOM Service"
    ],
    "directory": "dicom-scp",
    "file": "dicom-scp/pipelines/dicom-scp.toml",
    "type": "pipeline"
  },
  "dicomweb-dicom": {
    "name": "DICOMweb to DICOM",
    "shortDescription": "Web-based DICOM services",
    "description": "DICOM Service Class Provider supporting web protocols. Enables browser-based access to medical imaging with C-ECHO, C-FIND, C-GET, C-MOVE operations.",
    "tags": [
      "Healthcare",
      "DICOM",
      "DICOMweb"
    ],
    "useCases": [
      {
        "title": "Web Imaging Access",
        "description": "Access DICOM images through web protocols"
      },
      {
        "title": "Cloud Integration",
        "description": "Enable cloud-based DICOM workflows"
      },
      {
        "title": "Modern Viewer Support",
        "description": "Support web-based DICOM viewers and applications"
      }
    ],
    "prerequisites": [
      "DICOMweb Service",
      "DICOM SCU Backend"
    ],
    "directory": "dicomweb",
    "file": "dicomweb/pipelines/dicomweb.toml",
    "type": "pipeline"
  },
  "fhir": {
    "name": "FHIR Integration",
    "shortDescription": "Connect to FHIR-compliant health systems",
    "description": "Proxy for FHIR resources with authentication and validation. Routes healthcare data to FHIR servers with security headers and JSON extraction.",
    "tags": [
      "Healthcare",
      "FHIR"
    ],
    "useCases": [
      {
        "title": "FHIR Server Integration",
        "description": "Connect to Firely or other FHIR servers with authentication"
      },
      {
        "title": "Healthcare Interoperability",
        "description": "Secure FHIR resource exchange between health systems"
      },
      {
        "title": "Data Extraction",
        "description": "Extract and route specific FHIR resources"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Echo Backend"
    ],
    "directory": "fhir",
    "file": "fhir/pipelines/fhir.toml",
    "type": "pipeline"
  },
  "fhir-dicom": {
    "name": "FHIR to DICOM Integration",
    "shortDescription": "Unified clinical and imaging data pipeline",
    "description": "Full bidirectional pipeline converting between FHIR and DICOM formats. Links clinical orders with imaging studies and produces FHIR ImagingStudy bundles.",
    "tags": [
      "Healthcare",
      "FHIR",
      "DICOM"
    ],
    "useCases": [
      {
        "title": "Radiology Workflow",
        "description": "Link FHIR radiology orders with DICOM imaging studies"
      },
      {
        "title": "Comprehensive Records",
        "description": "Create FHIR ImagingStudy bundles with clinical context"
      },
      {
        "title": "Data Normalization",
        "description": "Convert between FHIR and DICOM formats seamlessly"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "DICOM Backend"
    ],
    "directory": "fhir_dicom",
    "file": "fhir_dicom/pipelines/fhir_imagingstudy.toml",
    "type": "pipeline"
  },
  "http-content-type": {
    "name": "Content Type Handling",
    "shortDescription": "Multi-format data negotiation",
    "description": "Handle multiple content types (JSON, FHIR JSON, DICOM JSON) automatically. Parse and route requests based on MIME type detection.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Format Negotiation",
        "description": "Automatically detect and handle multiple content types"
      },
      {
        "title": "Multi-Format Support",
        "description": "Accept JSON, FHIR+JSON, DICOM+JSON in same endpoint"
      },
      {
        "title": "Flexible Integration",
        "description": "Connect diverse systems with format adaptation"
      }
    ],
    "prerequisites": [],
    "directory": "content-types",
    "file": "content-types/pipelines/multi-content.toml",
    "type": "pipeline"
  },
  "jmix": {
    "name": "JMIX to DICOM",
    "shortDescription": "Share JMIX packages from DICOM services",
    "description": "Integrate JMIX applications with DICOM infrastructure. Secure proxy with performance optimization and schema validation.",
    "tags": [
      "Healthcare",
      "DICOM",
      "JMIX"
    ],
    "useCases": [
      {
        "title": "JMIX to External Systems",
        "description": "Connect JMIX apps to third-party APIs and services"
      },
      {
        "title": "DICOM Integration",
        "description": "Link JMIX applications with medical imaging systems"
      },
      {
        "title": "Enterprise Integration",
        "description": "Enterprise-grade application connectivity"
      }
    ],
    "prerequisites": [
      "JMIX Service",
      "DICOM Backend"
    ],
    "directory": "jmix",
    "file": "jmix/pipelines/jmix-performance.toml",
    "type": "pipeline"
  },
  "soap-to-json": {
    "name": "SOAP to JSON Bridge",
    "shortDescription": "Convert SOAP to modern JSON APIs",
    "description": "Transform legacy SOAP messages to JSON format via JOLT. Enables modern client access to SOAP-based backend systems with JWT authentication.",
    "tags": [
      "SOAP",
      "XML",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Legacy System Modernization",
        "description": "Expose SOAP services as JSON APIs"
      },
      {
        "title": "Client Migration",
        "description": "Support both SOAP and JSON clients during transition"
      },
      {
        "title": "Format Translation",
        "description": "Automatic XML to JSON conversion with JOLT"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "JWT Auth Middleware",
      "Transform Middleware"
    ],
    "directory": "soap-to-json",
    "file": "soap-to-json/pipelines/soap-to-json.toml",
    "type": "pipeline"
  },
  "transform": {
    "name": "Data Transformation",
    "shortDescription": "JSON data reshaping with JOLT",
    "description": "Transform and reshape JSON data using JOLT mappings. Convert between data formats, normalize schemas, and enrich data in flight.",
    "tags": [
      "HTTP",
      "REST",
      "Transform"
    ],
    "useCases": [
      {
        "title": "Schema Conversion",
        "description": "Transform patient records to FHIR format"
      },
      {
        "title": "Data Normalization",
        "description": "Reshape and standardize JSON data"
      },
      {
        "title": "Format Translation",
        "description": "Convert between different data schemas"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "transform",
    "file": "transform/pipelines/transform-example.toml",
    "type": "pipeline"
  },
  "au-erequesting-http-to-fhir": {
    "name": "AU eRequesting: HTTP to FHIR",
    "shortDescription": "Convert HTTP service requests to AU eRequesting FHIR bundles",
    "description": "Convert HTTP service requests to AU eRequesting FHIR bundles and back to HTTP responses.",
    "tags": [
      "Healthcare",
      "FHIR",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "eRequesting Integration",
        "description": "Integrate with the Australian eRequesting specification"
      },
      {
        "title": "FHIR Bundle Generation",
        "description": "Generate compliant FHIR bundles from HTTP requests"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "FHIR Service",
      "Transform Middleware"
    ],
    "directory": "au-erequesting",
    "file": "au-erequesting/pipelines/http-to-fhir.toml",
    "type": "pipeline"
  },
  "au-erequesting-fhir-to-http": {
    "name": "AU eRequesting: FHIR to HTTP",
    "shortDescription": "Accept AU eRequesting FHIR bundles and convert to HTTP API calls",
    "description": "Accept AU eRequesting FHIR bundles and convert to HTTP API calls for backend services.",
    "tags": [
      "Healthcare",
      "FHIR",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "FHIR to REST",
        "description": "Convert FHIR bundles to backend REST calls"
      },
      {
        "title": "eRequesting Backend",
        "description": "Accept eRequesting messages for processing"
      }
    ],
    "prerequisites": [
      "FHIR Service",
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "au-erequesting",
    "file": "au-erequesting/pipelines/fhir-to-http.toml",
    "type": "pipeline"
  },
  "webhook": {
    "name": "Webhook Middleware",
    "shortDescription": "Emit JSON payloads on request/response",
    "description": "Demonstrates the webhook middleware for emitting JSON payloads on request/response, with per-instance authentication and header redaction.",
    "tags": [
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Event Notification",
        "description": "Send webhook events on request/response"
      },
      {
        "title": "Audit Logging",
        "description": "Emit payloads for external audit systems"
      }
    ],
    "prerequisites": [
      "HTTP Service"
    ],
    "directory": "webhook",
    "file": "webhook/pipelines/webhook.toml",
    "type": "pipeline",
    "since": "0.11"
  },
  "santas-workshop": {
    "name": "Santa's Workshop",
    "shortDescription": "North Pole Gift Distribution Network",
    "description": "Mission-critical pipeline powering Santa's Gift Distribution Network. Integrates the Naughty/Nice Registry, Elf Production Management System (EPMS), and Reindeer Fleet Logistics API for seamless Christmas Eve operations.",
    "tags": [
      "HTTP",
      "REST",
      "Demo"
    ],
    "useCases": [
      {
        "title": "Gift Routing",
        "description": "High-throughput gift routing with sub-millisecond latency to chimneys worldwide"
      },
      {
        "title": "Naughty/Nice Classification",
        "description": "Real-time eligibility verification against the authoritative Nice List"
      },
      {
        "title": "Reindeer Fleet Management",
        "description": "Load-balanced sleigh assignments with Rudolph failover support"
      }
    ],
    "prerequisites": [
      "North Pole VPN",
      "Elf API Token",
      "Reindeer Fleet Credentials"
    ],
    "directory": "santas-workshop",
    "file": "santas-workshop/pipelines/santas-workshop.toml",
    "type": "pipeline",
    "featured": true,
    "runbeam": false,
    "deployVideo": "https://youtu.be/E8gmARGvPlI?si=VqC0jnuCLnPmm6dj"
  },
  "dicom_to_dicomweb": {
    "name": "DICOM to DICOMweb",
    "shortDescription": "Convert DICOM requests to the DICOMweb protocol",
    "description": "Bridge that accepts incoming DICOM requests from imaging modalities and converts them to DICOMweb protocol for web-based access. Enables legacy DICOM devices to integrate with modern DICOMweb-based systems.",
    "tags": [
      "Healthcare",
      "DICOM",
      "DICOMweb"
    ],
    "useCases": [
      {
        "title": "Legacy DICOM Integration",
        "description": "Connect traditional DICOM modalities to DICOMweb systems"
      },
      {
        "title": "Protocol Translation",
        "description": "Automatically convert DICOM network protocols to web standards"
      },
      {
        "title": "Cloud integration",
        "description": "Enable communication between DICOM and cloud providers"
      }
    ],
    "prerequisites": [
      "DICOM Modalities",
      "DICOMweb Server"
    ],
    "directory": "dicom_to_dicomweb",
    "file": "dicom_to_dicomweb/pipelines/bridge.toml",
    "type": "pipeline"
  },
  "ucp-checkout": {
    "name": "UCP Checkout",
    "shortDescription": "Universal Commerce Protocol checkout capability",
    "description": "Implements Universal Commerce Protocol (UCP) checkout capability for agentic commerce. Enables AI agents to discover capabilities, create checkout sessions, negotiate payment handlers, and complete purchases on behalf of users using standardized UCP endpoints.",
    "tags": [
      "HTTP",
      "REST",
      "Commerce",
      "AI"
    ],
    "useCases": [
      {
        "title": "Agentic Commerce",
        "description": "Enable AI agents to complete purchases autonomously"
      },
      {
        "title": "UCP Gateway",
        "description": "Expose commerce capabilities via standardized UCP endpoints"
      },
      {
        "title": "Payment Negotiation",
        "description": "Dynamic payment handler selection with Google Pay, Shop Pay, card tokenization"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware",
      "JSON Extractor",
      "AI"
    ],
    "directory": "ucp-checkout",
    "file": "ucp-checkout/pipelines/checkout-create.toml",
    "type": "pipeline",
    "featured": true
  },
  "jmix-backend": {
    "name": "JMIX Backend Forwarding",
    "shortDescription": "Forward JMIX POST and GET requests to upstream servers",
    "description": "Proxy layer for forwarding JMIX envelope uploads (POST) and retrievals (GET) to upstream JMIX servers. Enables building JMIX distribution networks with security and access control.",
    "tags": [
      "Healthcare",
      "JMIX"
    ],
    "useCases": [
      {
        "title": "JMIX Distribution Network",
        "description": "Forward JMIX envelopes between organizations and systems"
      },
      {
        "title": "Edge Proxy",
        "description": "Add security and access control to existing JMIX infrastructure"
      },
      {
        "title": "Multi-Tier Architecture",
        "description": "Build hierarchical JMIX storage and distribution systems"
      }
    ],
    "prerequisites": [
      "JMIX Service",
      "Upstream JMIX Server"
    ],
    "directory": "jmix-backend",
    "file": "jmix-backend/pipelines/jmix-backend.toml",
    "type": "pipeline"
  },
  "dicom-to-jmix": {
    "name": "DICOM C-STORE to JMIX",
    "shortDescription": "Receive DICOM images and package into JMIX envelopes",
    "description": "Bridge pipeline that receives DICOM images via C-STORE and automatically packages them into JMIX envelopes for upstream storage. Ideal for converting DICOM workflows to JMIX distribution systems.",
    "tags": [
      "Healthcare",
      "DICOM",
      "JMIX"
    ],
    "useCases": [
      {
        "title": "DICOM to JMIX Gateway",
        "description": "Convert traditional DICOM workflows to JMIX-based distribution"
      },
      {
        "title": "Modality Integration",
        "description": "Receive images from CT/MRI/Ultrasound and package for cloud storage"
      },
      {
        "title": "PACS Bridge",
        "description": "Integrate legacy PACS systems with modern JMIX repositories"
      }
    ],
    "prerequisites": [
      "DICOM Service",
      "JMIX Service",
      "Upstream JMIX Server"
    ],
    "directory": "dicom-to-jmix",
    "file": "dicom-to-jmix/pipelines/dicom-to-jmix.toml",
    "type": "pipeline"
  },
  "data-mesh": {
    "name": "Data Mesh",
    "shortDescription": "Secure inter-proxy communication network",
    "description": "Demonstrates Harmony's Data Mesh feature for secure inter-proxy communication. Enables multiple Harmony instances to communicate as a distributed network with secure authentication and routing between mesh members.",
    "tags": [
      "Healthcare",
      "FHIR",
      "Mesh-Networking"
    ],
    "useCases": [
      {
        "title": "Multi-Org Data Exchange",
        "description": "Secure healthcare data exchange between organizations"
      },
      {
        "title": "Mesh Networking",
        "description": "Configure ingress/egress for inter-service communication"
      },
      {
        "title": "Partner Integration",
        "description": "Connect to partner FHIR servers and imaging centers"
      }
    ],
    "prerequisites": [
      "FHIR Service",
      "HTTP Service"
    ],
    "directory": "data-mesh",
    "file": "data-mesh/pipelines/api.toml",
    "type": "pipeline"
  },
  "http-file-upload": {
    "name": "HTTP File Upload",
    "shortDescription": "Upload files to local storage via HTTP",
    "description": "Route HTTP requests with binary payloads directly to the storage backend (local filesystem). Supports automatic UUID-based naming for uploaded files.",
    "tags": [
      "HTTP",
      "REST",
      "Storage",
      "File-Transfer"
    ],
    "useCases": [
      {
        "title": "File Uploads",
        "description": "Handle file uploads in HTTP APIs"
      },
      {
        "title": "Binary Storage",
        "description": "Store binary data with automatic naming"
      },
      {
        "title": "File Management",
        "description": "Build file management services with Harmony"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Storage Backend"
    ],
    "directory": "http-file-upload",
    "file": "http-file-upload/pipelines/upload.toml",
    "type": "pipeline"
  },
  "http-with-middleware": {
    "name": "HTTP with Middleware",
    "shortDescription": "Comprehensive middleware chain example",
    "description": "Comprehensive integration test of all major Harmony features in a single pipeline. Demonstrates authentication, access control, path filtering, JSON extraction, and JOLT transformations.",
    "tags": [
      "HTTP",
      "REST",
      "Transform",
      "Middleware"
    ],
    "useCases": [
      {
        "title": "Learning Middleware",
        "description": "Understand all Harmony middleware capabilities"
      },
      {
        "title": "Production Template",
        "description": "Use as a template for production pipelines"
      },
      {
        "title": "Integration Testing",
        "description": "Test complete middleware chains"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware",
      "Basic Auth"
    ],
    "directory": "http-with-middleware",
    "file": "http-with-middleware/pipelines/pipeline.toml",
    "type": "pipeline"
  },
  "dicom-ai": {
    "name": "DICOM to AI Gateway",
    "shortDescription": "Transform DICOM to JSON for cloud AI processing",
    "description": "Receive DICOM images from PACS systems and transform them into JSON requests for cloud-based AI processing services. Extracts key metadata and restructures it for machine learning pipelines.",
    "tags": [
      "Healthcare",
      "DICOM",
      "AI",
      "Transform"
    ],
    "useCases": [
      {
        "title": "Medical Image Analysis",
        "description": "Route DICOM studies to cloud AI for automated analysis"
      },
      {
        "title": "AI Pipeline Integration",
        "description": "Convert DICOM to JSON format for ML model processing"
      },
      {
        "title": "Radiology AI Services",
        "description": "Enable AI-powered diagnostic support from existing PACS"
      }
    ],
    "prerequisites": [
      "DICOM Service",
      "HTTP Service",
      "AI"
    ],
    "directory": "dicom-ai",
    "file": "dicom-ai/pipelines/dicom-to-ai.toml",
    "type": "pipeline",
    "featured": true
  },
  "fhir-to-legacy": {
    "name": "FHIR to Legacy HTTP",
    "shortDescription": "Accept FHIR resources and transform for legacy HTTP systems",
    "description": "Accept FHIR R4 resources and transform them for legacy systems that don't speak FHIR. Bridges modern FHIR-compliant applications with older HTTP APIs using JOLT transformations.",
    "tags": [
      "Healthcare",
      "FHIR",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Legacy System Integration",
        "description": "Connect FHIR-enabled EHRs with legacy patient management systems"
      },
      {
        "title": "FHIR to Flat JSON",
        "description": "Convert FHIR resources to simple flat JSON structures"
      },
      {
        "title": "Gradual FHIR Adoption",
        "description": "Enable FHIR adoption without replacing legacy backends"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "fhir-to-legacy",
    "file": "fhir-to-legacy/pipelines/fhir-to-legacy.toml",
    "type": "pipeline"
  },
  "legacy-to-fhir": {
    "name": "Legacy HTTP to FHIR",
    "shortDescription": "Accept legacy HTTP requests and convert to FHIR resources",
    "description": "Accept HTTP requests from legacy systems and convert them to FHIR requests. Enables older applications to communicate with modern FHIR servers without needing to understand FHIR.",
    "tags": [
      "Healthcare",
      "FHIR",
      "HTTP",
      "REST"
    ],
    "useCases": [
      {
        "title": "Legacy to FHIR Bridge",
        "description": "Connect legacy patient systems to FHIR servers"
      },
      {
        "title": "Incremental Migration",
        "description": "Migrate applications to FHIR incrementally"
      },
      {
        "title": "FHIR Facade",
        "description": "Provide a FHIR-compatible facade for existing APIs"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "legacy-to-fhir",
    "file": "legacy-to-fhir/pipelines/legacy-to-fhir.toml",
    "type": "pipeline"
  },
  "webhook-to-fhir": {
    "name": "Webhook to FHIR",
    "shortDescription": "Receive webhooks and transform to FHIR resources",
    "description": "Receive webhooks from any system and transform payloads into FHIR resources. Supports patient registration, appointment booking, and lab result notifications with flexible field mapping.",
    "tags": [
      "Healthcare",
      "FHIR",
      "HTTP",
      "REST",
      "Webhook",
      "Transform"
    ],
    "useCases": [
      {
        "title": "SaaS Integration",
        "description": "Integrate SaaS applications with FHIR systems via webhooks"
      },
      {
        "title": "Event-Driven FHIR",
        "description": "Build event-driven FHIR data pipelines from external events"
      },
      {
        "title": "Multi-Source Ingestion",
        "description": "Receive patient, appointment, and lab data from multiple sources"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "webhook-to-fhir",
    "file": "webhook-to-fhir/pipelines/webhook-to-fhir.toml",
    "type": "pipeline"
  },
  "mcp-to-http": {
    "name": "MCP to HTTP Bridge",
    "shortDescription": "Bridge MCP protocol to standard HTTP APIs",
    "description": "Transform MCP (Model Context Protocol) requests from AI agents into standard HTTP API calls. Enables AI systems using MCP to communicate with existing HTTP backends without native MCP support.",
    "tags": [
      "HTTP",
      "REST",
      "AI",
      "MCP",
      "Transform"
    ],
    "useCases": [
      {
        "title": "AI Agent Integration",
        "description": "Allow AI agents to use MCP to call existing REST APIs"
      },
      {
        "title": "Protocol Translation",
        "description": "Convert MCP JSON-RPC to standard HTTP requests"
      },
      {
        "title": "Legacy API Access",
        "description": "Expose HTTP services to AI agents via MCP protocol"
      }
    ],
    "prerequisites": [
      "HTTP Service",
      "Transform Middleware"
    ],
    "directory": "mcp-to-http",
    "file": "mcp-to-http/pipelines/mcp-to-http.toml",
    "type": "pipeline",
    "featured": true
  }
}
